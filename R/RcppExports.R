# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' remstatsCpp
#'
#' A function to compute statistics and combine the statistics in an array
#' prepared for estimation of a REM with relevent::rem(). Used internally 
#' in remstats. 
#' 
#' param:
#' [effects] integer vector (effects)
#' [standardize] logical, indicates whether statistics for endogenous effects 
#' should be standardized
#' [edgelist] 3-column edgelist (time, sender, receiver)
#' [riskset] 2-column riskset (sender/actor 1, receiver/actor 2)
#' [evls] 2-column edgelist (event, time) in relevent::rem format
#' [actors] vector with numeric actor IDs (correspod to edgelist, riskset)
#' [covariates] List with matrices
#'     0: [sender_values] matrix (id, time, covariate values)
#'     1: [receiver_values] matrix(id, time, covariate values)
#'     2: [same] matrix(id, time, covariate values)
#'     3: [difference] matrix(id, time, covariate values)
#'     4: [mean] matrix(id, time, covariate values)
#'     5: [min] matrix(id, time, covariate values)
#'     6: [max] matrix(id, time, covariate values)
#'     7: [both_equal_to] matrix(id, time, covariate values)
#' [event_effect] matrix (event effect per column)
#' [weights] vector (length evls) 
#' [equal_val] vector (length ncol both_equal_to minus 2)
#' [int_positions] matrix (effect 1, effect 2)
#'
#' return:
#' [statistics] 3-dimensional array (event time x risk set entry x statistic)
#' 
remstatsCpp <- function(effects, standardize, edgelist, riskset, evls, actors, covariates, event_effect, weights, equal_val, int_positions) {
    .Call(`_remstats_remstatsCpp`, effects, standardize, edgelist, riskset, evls, actors, covariates, event_effect, weights, equal_val, int_positions)
}

#' remstatsMWCpp
#'
#' A function to compute statistics and combine the statistics in an array
#' prepared for estimation of a moving window REM with relevent::rem(). Used 
#' internally in remstatsMW. 
#' 
#' @param effects integer vector (effects)
#' @param standardize logical, indicates whether statistics for endogenous 
#' effects should be standardized
#' @param full_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_lenght numeric value.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param full_evls 2-column edgelist (event, time) in relevent::rem format
#' @param window_evls 2-column edgelist (event, time) in relevent::rem format
#' @param actors vector with numeric actor IDs (correspod to edgelist, riskset)
#' @param covariates List with matrices
#'     0: [sender_values] matrix (id, time, covariate values)
#'     1: [receiver_values] matrix(id, time, covariate values)
#'     2: [same] matrix(id, time, covariate values)
#'     3: [difference] matrix(id, time, covariate values)
#'     4: [mean] matrix(id, time, covariate values)
#'     5: [min] matrix(id, time, covariate values)
#'     6: [max] matrix(id, time, covariate values)
#'     7: [both_equal_to] matrix(id, time, covariate values)
#' @param event_effect matrix (event effect per column)
#' @param full_weights vector (length evls) 
#' @param equal_val vector (length ncol both_equal_to minus 2)
#' @param int_positions matrix (effect 1, effect 2)
#'
#' return:
#' [statistics] 3-dimensional array (event time x risk set entry x statistic)
#' 
remstatsMWCpp <- function(effects, standardize, full_edgelist, window_edgelist, window_length, riskset, full_evls, window_evls, actors, covariates, event_effect, full_weights, equal_val, int_positions) {
    .Call(`_remstats_remstatsMWCpp`, effects, standardize, full_edgelist, window_edgelist, window_length, riskset, full_evls, window_evls, actors, covariates, event_effect, full_weights, equal_val, int_positions)
}

#' TO DO: Create R wrapper functions for these cpp functions and export those instead of the ones below.
NULL

#' actorStat
#'
#' A function to transform exogenous actor covariate variables in the format 
#' requested for estimation with relevent::rem(). 
#'
#' @param values 3-column matrix (id, change time, value). Actor ids should 
#' correspond to actor ids in the edgelist and riskset. Change time is zero 
#' for all entries if the covariate is time invariate. 
#' @param type 1 = sender effect, 2 = receiver effect
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' data(covar)
#' out <- prepER(edgelist = edgelistD)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' covar$id <- ac$id[match(covar$id, ac$name)]
#' covar <- as.matrix(covar)
#' stat <- actorStat(values = covar[,c(1:3)], type = 1, edgelist = el, 
#'     riskset = rs)
#'
#' @export
#'
actorStat <- function(values, type, edgelist, riskset) {
    .Call(`_remstats_actorStat`, values, type, edgelist, riskset)
}

#' dyadstat
#'
#' A function to transform exogenous actor covariate variables in dyad 
#' statistics.
#'
#' @param values 3-column matrix (id, change time, value). Actor ids should 
#' correspond to actor ids in the edgelist and riskset. Change time is zero 
#' for all entries if the covariate is time invariate. 
#' @param type 1 = same, 2 = difference, 3 = mean, 4 = min, 5 = max, 
#' 6 = both equal to
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#' @param equal_val value
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistU)
#' data(covar)
#' out <- prepER(edgelist = edgelistU, directed = FALSE)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors    
#' covar$id <- ac$id[match(covar$id, ac$name)]
#' covar <- as.matrix(covar)
#' stat <- dyadstat(values = covar[,c(1:3)], type = 1, edgelist = el, 
#'     riskset = rs, NA)
#'
#' @export
#'
dyadstat <- function(values, type, edgelist, riskset, equal_val) {
    .Call(`_remstats_dyadstat`, values, type, edgelist, riskset, equal_val)
}

#' inertia
#'
#' A function to compute the inertia effect.
#'
#' @param evls 2-column edgelist (event, time) in relevent::rem format.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#' @param weights vector (length evls) 
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' evls <- prepEvls(el, rs, type = FALSE)
#' stat <- inertia(evls, rs, weights = rep(1, nrow(el)), FALSE)
#'
#' @export
#'
inertia <- function(evls, riskset, weights, standardize) {
    .Call(`_remstats_inertia`, evls, riskset, weights, standardize)
}

#' reciprocity
#'
#' A function to compute the indegree, outdegree and total degree effects.
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' stat <- reciprocity(el, rs, FALSE)
#'
#' @export
#'
reciprocity <- function(edgelist, riskset, standardize) {
    .Call(`_remstats_reciprocity`, edgelist, riskset, standardize)
}

#' degree
#'
#' A function to compute the indegree, outdegree and total degree effects.
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param type 1 = indegree_sender, 2 = indegree_receiver, 3 = 
#' outdegree_sender, 4 = outdegree_receiver, 5 = totaldegree_sender, 6 = 
#' totaldegree_receiver 
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' indegree_sender <- degree(edgelist = el, riskset = rs, type = 1, 
#'     standardize = FALSE)
#'
#' @export
#'
degree <- function(edgelist, riskset, type, standardize) {
    .Call(`_remstats_degree`, edgelist, riskset, type, standardize)
}

#' triad
#'
#' A function to compute the triadic effects.
#' 
#' @param actors vector with numeric actor IDs (correspod to edgelist, riskset)
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param type (1 = outgoing two-path, 2 = incoming two-path, 3 = outbound 
#' shared partners, 4 = inbound shared partners)
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors[,1]
#' otp <- triad(ac, el, rs, type = 1, standardize = FALSE)
#'
#' @export
#'
triad <- function(actors, edgelist, riskset, type, standardize) {
    .Call(`_remstats_triad`, actors, edgelist, riskset, type, standardize)
}

#' triadU
#'
#' A function to compute the (unique) shared partners effect for undirected 
#' relational events.
#'
#' @param actors vector with numeric actor IDs (correspond to edgelist,
#' riskset)
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param unique_sp logical value
#' @param standardize logical value
#'
#' @return matrix (time x dyad)
#' 
#' @examples
#' data(edgelistU)
#' out <- prepER(edgelist = edgelistU, directed = FALSE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors[,1]
#' stat <- triadU(ac, el, rs, unique_sp = FALSE, standardize = FALSE)
#'
#' @export
#'
triadU <- function(actors, edgelist, riskset, unique_sp, standardize) {
    .Call(`_remstats_triadU`, actors, edgelist, riskset, unique_sp, standardize)
}

#' inertiaMW
#'
#' A function to compute the inertia effect.
#'
#' @param full_evls 2-column edgelist (event, time) in relevent::rem format.
#' @param window_evls 2-column edgelist (event, time) in relevent::rem format.
#' @param window_length numeric value.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#' @param full_weights vector (length full_evls). 
#' @param standardize logical. 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistU)
#' windows <- data.frame(start = seq(0, 900, 75), end = seq(100, 1000, 75))
#' window_edgelist <- edgelistU[edgelistU$time > windows$start[2] & 
#'     edgelistU$time <= windows$end[2],]
#' out <- prepER(edgelist = edgelistU, directed = FALSE)
#' full_el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' out <- prepER(window_edgelist, directed = FALSE, actors = ac[,2])
#' window_el <- out$edgelist
#' full_evls <- prepEvls(full_el, rs)
#' window_evls <- prepEvls(window_el, rs)
#' stat <- inertiaMW(full_evls = full_evls, window_evls = window_evls, 
#' window_length = 100, riskset = rs, full_weights = rep(1, nrow(el)), 
#' standardize = FALSE)
#'
#' @export
#'
inertiaMW <- function(full_evls, window_evls, window_length, riskset, full_weights, standardize) {
    .Call(`_remstats_inertiaMW`, full_evls, window_evls, window_length, riskset, full_weights, standardize)
}

#' triadUMW
#'
#' A function to compute the (unique) shared partners effect for undirected 
#' relational events when fitting a moving window REM.
#'
#' @param actors vector with numeric actor IDs (correspond to edgelist,
#' riskset)
#' @param full_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_length numeric value.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param unique_sp logical value
#' @param standardize logical value
#'
#' @return matrix (time x dyad)
#' 
#' @examples
#' windows <- data.frame(start = seq(0, 900, 75), end = seq(100, 1000, 75))
#' window_edgelist <- edgelistU[edgelistU$time > windows$start[2] & 
#'     edgelistU$time <= windows$end[2],]
#' out <- prepER(edgelist = edgelistU, directed = FALSE)
#' full_el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' out <- prepER(window_edgelist, directed = FALSE, actors = ac[,2])
#' window_el <- out$edgelist
#' stat <- triadU(actors = ac[,1], full_edgelist = full_el, 
#'     window_edgelist = window_el, window_length = 100, riskset = rs, 
#'     unique_sp = FALSE, standardize = FALSE)
#'
#' @export
#'
triadUMW <- function(actors, full_edgelist, window_edgelist, window_length, riskset, unique_sp, standardize) {
    .Call(`_remstats_triadUMW`, actors, full_edgelist, window_edgelist, window_length, riskset, unique_sp, standardize)
}

