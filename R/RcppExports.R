# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' actorStat
#'
#' A function to transform exogenous actor covariate variables in the format 
#' requested for estimation with relevent::rem(). 
#'
#' @param values 3-column matrix (id, change time, value). Actor ids should 
#' correspond to actor ids in the edgelist and riskset. Change time is zero 
#' for all entries if the covariate is time invariate. 
#' @param type 1 = sender effect, 2 = receiver effect
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' data(covar)
#' out <- prepER(edgelist = edgelistD)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' covar$id <- ac$id[match(covar$id, ac$name)]
#' covar <- as.matrix(covar)
#' stat <- actorStat(values = covar[,c(1:3)], type = 1, edgelist = el, 
#'     riskset = rs)
#'
#' @export
#'
actorStat <- function(values, type, edgelist, riskset) {
    .Call(`_remstats_actorStat`, values, type, edgelist, riskset)
}

#' dyadstat
#'
#' A function to transform exogenous actor covariate variables in dyad 
#' statistics.
#'
#' @param values 3-column matrix (id, change time, value). Actor ids should 
#' correspond to actor ids in the edgelist and riskset. Change time is zero 
#' for all entries if the covariate is time invariate. 
#' @param type 1 = same, 2 = difference, 3 = mean, 4 = min, 5 = max, 
#' 6 = both equal to
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#' @param equal_val value
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistU)
#' data(covar)
#' out <- prepER(edgelist = edgelistU, directed = FALSE)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors    
#' covar$id <- ac$id[match(covar$id, ac$name)]
#' covar <- as.matrix(covar)
#' stat <- dyadstat(values = covar[,c(1:3)], type = 1, edgelist = el, 
#'     riskset = rs, NA)
#'
#' @export
#'
dyadstat <- function(values, type, edgelist, riskset, equal_val) {
    .Call(`_remstats_dyadstat`, values, type, edgelist, riskset, equal_val)
}

#' inertia
#'
#' A function to compute the inertia effect.
#'
#' @param evls 2-column edgelist (event, time) in relevent::rem format.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#' @param weights vector (length evls) 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' evls <- prepEvls(el, rs, type = FALSE)
#' stat <- inertia(evls, rs, weights = rep(1, nrow(el)))
#'
#' @export
#'
inertia <- function(evls, riskset, weights) {
    .Call(`_remstats_inertia`, evls, riskset, weights)
}

#' reciprocity
#'
#' A function to compute the indegree, outdegree and total degree effects.
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' stat <- reciprocity(el, rs)
#'
#' @export
#'
reciprocity <- function(edgelist, riskset) {
    .Call(`_remstats_reciprocity`, edgelist, riskset)
}

#' degree
#'
#' A function to compute the indegree, outdegree and total degree effects.
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param type 1 = indegree_sender, 2 = indegree_receiver, 3 = 
#' outdegree_sender, 4 = outdegree_receiver, 5 = totaldegree_sender, 6 = 
#' totaldegree_receiver 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' indegree_sender <- degree(el, rs, type = 1)
#'
#' @export
#'
degree <- function(edgelist, riskset, type) {
    .Call(`_remstats_degree`, edgelist, riskset, type)
}

#' triad
#'
#' A function to compute the triadic effects.
#' 
#' @param actors vector with numeric actor IDs (correspod to edgelist, riskset)
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param type (1 = outgoing two-path, 2 = incoming two-path, 3 = outbound 
#' shared partners, 4 = inbound shared partners)
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors[,1]
#' otp <- triad(ac, el, rs, type = 1)
#'
#' @export
#'
triad <- function(actors, edgelist, riskset, type) {
    .Call(`_remstats_triad`, actors, edgelist, riskset, type)
}

#' triadU
#'
#' A function to compute the (unique) shared partners effect for undirected 
#' relational events.
#'
#' @param actors vector with numeric actor IDs (correspond to edgelist,
#' riskset)
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param uinque_sp logical value
#'
#' @return matrix (time x dyad)
#' 
#' @examples
#' data(edgelistU)
#' out <- prepER(edgelist = edgelistU, directed = FALSE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors[,1]
#' stat <- triadU(ac, el, rs, unique_sp = FALSE)
#'
#' @export
#'
triadU <- function(actors, edgelist, riskset, unique_sp) {
    .Call(`_remstats_triadU`, actors, edgelist, riskset, unique_sp)
}

#' remStatsC
#'
#' A function to compute statistics and combine the statistics in an array
#' prepared for estimation of a REM with relevent::rem(). Used internally 
#' in remStats. 
#' 
#' param:
#' [effects] integer vector (effects)
#' [edgelist] 3-column edgelist (time, sender, receiver)
#' [riskset] 2-column riskset (sender/actor 1, receiver/actor 2)
#' [evls] 2-column edgelist (event, time) in relevent::rem format
#' [actors] vector with numeric actor IDs (correspod to edgelist, riskset)
#' [covariates] List with matrices
#'     0: [sender_values] matrix (id, time, covariate values)
#'     1: [receiver_values] matrix(id, time, covariate values)
#'     2: [same] matrix(id, time, covariate values)
#'     3: [difference] matrix(id, time, covariate values)
#'     4: [mean] matrix(id, time, covariate values)
#'     5: [min] matrix(id, time, covariate values)
#'     6: [max] matrix(id, time, covariate values)
#'     7: [both_equal_to] matrix(id, time, covariate values)
#' [event_effect] matrix (event effect per column)
#' [weights] vector (length evls) 
#' [equal_val] vector (length ncol both_equal_to minus 2)
#' [int_positions] matrix (effect 1, effect 2)
#'
#' return:
#' [statistics] 3-dimensional array (event time x risk set entry x statistic)
#' 
remStatsC <- function(effects, edgelist, riskset, evls, actors, covariates, event_effect, weights, equal_val, int_positions) {
    .Call(`_remstats_remStatsC`, effects, edgelist, riskset, evls, actors, covariates, event_effect, weights, equal_val, int_positions)
}

