# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' remstatsCpp
#'
#' A function to compute statistics and combine the statistics in an array
#' prepared for estimation of a REM with relevent::rem(). Used internally 
#' in remstats. 
#' 
#' @param effects integer vector (effects)
#' @param standardize logical, indicates whether statistics for endogenous 
#' effects should be standardized
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param actors vector with numeric actor IDs (correspod to edgelist, riskset)
#' @param covariates List with matrices
#'     0: [sender_values] matrix (id, time, covariate values)
#'     1: [receiver_values] matrix(id, time, covariate values)
#'     2: [same] matrix(id, time, covariate values)
#'     3: [difference] matrix(id, time, covariate values)
#'     4: [mean] matrix(id, time, covariate values)
#'     5: [min] matrix(id, time, covariate values)
#'     6: [max] matrix(id, time, covariate values)
#'     7: [both_equal_to] matrix(id, time, covariate values)
#' @param event_effect matrix (event effect per column)
#' @param types vector
#' @param weights vector (length evls) 
#' @param equal_val vector (length ncol both_equal_to minus 2)
#' @param int_positions matrix (effect 1, effect 2)
#'
#' @return statistics 3-dimensional array (event time x risk set entry x 
#' statistic)
#' 
remstatsCpp <- function(effects, standardize, edgelist, riskset, actors, covariates, event_effect, types, weights, equal_val, int_positions) {
    .Call('_remstats_remstatsCpp', PACKAGE = 'remstats', effects, standardize, edgelist, riskset, actors, covariates, event_effect, types, weights, equal_val, int_positions)
}

#' remstatsMWCpp
#'
#' A function to compute statistics and combine the statistics in an array
#' prepared for estimation of a moving window REM with relevent::rem(). Used 
#' internally in remstatsMW. 
#' 
#' @param effects integer vector (effects)
#' @param standardize logical, indicates whether statistics for endogenous 
#' effects should be standardized
#' @param full_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_length numeric value.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param actors vector with numeric actor IDs (correspod to edgelist, riskset)
#' @param covariates List with matrices
#'     0: [sender_values] matrix (id, time, covariate values)
#'     1: [receiver_values] matrix(id, time, covariate values)
#'     2: [same] matrix(id, time, covariate values)
#'     3: [difference] matrix(id, time, covariate values)
#'     4: [mean] matrix(id, time, covariate values)
#'     5: [min] matrix(id, time, covariate values)
#'     6: [max] matrix(id, time, covariate values)
#'     7: [both_equal_to] matrix(id, time, covariate values)
#' @param event_effect matrix (event effect per column)
#' @param types vector
#' @param full_weights vector (length evls) 
#' @param equal_val vector (length ncol both_equal_to minus 2)
#' @param int_positions matrix (effect 1, effect 2)
#'
#' @return statistics 3-dimensional array (event time x risk set entry x 
#' statistic)
#' 
remstatsMWCpp <- function(effects, standardize, full_edgelist, window_edgelist, window_length, riskset, actors, covariates, event_effect, types, full_weights, equal_val, int_positions) {
    .Call('_remstats_remstatsMWCpp', PACKAGE = 'remstats', effects, standardize, full_edgelist, window_edgelist, window_length, riskset, actors, covariates, event_effect, types, full_weights, equal_val, int_positions)
}

#' recency
#'
#' A function to compute the rank-based recency effect, as in section 2.2.5 of Butts (2008).
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param actors vector of integers indicating the identity of the actors in the network
#' @param type equals 1 for outgoing and 2 for incoming recency effect
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD)
#' edgelist <- out$edgelist
#' actors <- out$actors$id
#' type <- 1
#' stat <- recency(edgelist, actors, type)
#'
#' @export
#'
NULL

#' actorstat
#'
#' A function to transform exogenous actor covariate variables in the format 
#' requested for estimation with relevent::rem(). 
#'
#' @param values 3-column matrix (id, change time, value). Actor ids should 
#' correspond to actor ids in the edgelist and riskset. Change time is zero 
#' for all entries if the covariate is time invariate. 
#' @param type 1 = sender effect, 2 = receiver effect
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' data(covar)
#' out <- prepER(edgelist = edgelistD)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' covar$id <- ac$id[match(covar$id, ac$name)]
#' covar <- as.matrix(covar)
#' stat <- actorstat(values = covar[,c(1:3)], type = 1, edgelist = el, 
#'     riskset = rs)
#'
#' @export
#'
actorstat <- function(values, type, edgelist, riskset) {
    .Call('_remstats_actorstat', PACKAGE = 'remstats', values, type, edgelist, riskset)
}

#' dyadstat
#'
#' A function to transform exogenous actor covariate variables in dyad 
#' statistics.
#'
#' @param values 3-column matrix (id, change time, value). Actor ids should 
#' correspond to actor ids in the edgelist and riskset. Change time is zero 
#' for all entries if the covariate is time invariate. 
#' @param type 1 = same, 2 = difference, 3 = mean, 4 = min, 5 = max, 
#' 6 = both equal to
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#' @param equal_val value
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistU)
#' data(covar)
#' out <- prepER(edgelist = edgelistU, directed = FALSE)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors    
#' covar$id <- ac$id[match(covar$id, ac$name)]
#' covar <- as.matrix(covar)
#' stat <- dyadstat(values = covar[,c(1:3)], type = 1, edgelist = el, 
#'     riskset = rs, NA)
#'
#' @export
#'
dyadstat <- function(values, type, edgelist, riskset, equal_val) {
    .Call('_remstats_dyadstat', PACKAGE = 'remstats', values, type, edgelist, riskset, equal_val)
}

#' inertia
#'
#' A function to compute the inertia effect.
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param weights vector (length edgelist) 
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD)
#' edgelist <- out$edgelist
#' riskset <- out$riskset
#' equal_weights <- rep(1, nrow(edgelist))
#' stat <- inertia(edgelist, riskset, equal_weights, standardize = FALSE)
#'
#' @export
#'
inertia <- function(edgelist, riskset, weights, standardize) {
    .Call('_remstats_inertia', PACKAGE = 'remstats', edgelist, riskset, weights, standardize)
}

#' reciprocity
#'
#' A function to compute reciprocity.
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param weights vector (length edgelist) 
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD)
#' edgelist <- out$edgelist
#' riskset <- out$riskset
#' equal_weights <- rep(1, nrow(edgelist))
#' stat <- reciprocity(edgelist, riskset, equal_weights, standardize = FALSE)
#'
#' @export
#'
reciprocity <- function(edgelist, riskset, weights, standardize) {
    .Call('_remstats_reciprocity', PACKAGE = 'remstats', edgelist, riskset, weights, standardize)
}

#' degree
#'
#' A function to compute the indegree, outdegree and total degree effects.
#' 
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param type 1 = indegree_sender, 2 = indegree_receiver, 3 = 
#' outdegree_sender, 4 = outdegree_receiver, 5 = totaldegree_sender, 6 = 
#' totaldegree_receiver 
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' indegree_sender <- degree(edgelist = el, riskset = rs, type = 1, 
#'     standardize = FALSE)
#'
#' @export
#'
degree <- function(edgelist, riskset, type, standardize) {
    .Call('_remstats_degree', PACKAGE = 'remstats', edgelist, riskset, type, standardize)
}

#' triad
#'
#' A function to compute the triadic effects.
#' 
#' @param actors vector with numeric actor IDs (correspod to edgelist, riskset)
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param type (1 = outgoing two-path, 2 = incoming two-path, 3 = outbound 
#' shared partners, 4 = inbound shared partners)
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelist = edgelistD, directed = TRUE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors[,1]
#' otp <- triad(ac, el, rs, type = 1, standardize = FALSE)
#'
#' @export
#'
triad <- function(actors, edgelist, riskset, type, standardize) {
    .Call('_remstats_triad', PACKAGE = 'remstats', actors, edgelist, riskset, type, standardize)
}

#' triadU
#'
#' A function to compute the (unique) shared partners effect for undirected 
#' relational events.
#'
#' @param actors vector with numeric actor IDs (correspond to edgelist,
#' riskset)
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param unique_sp logical value
#' @param standardize logical value
#'
#' @return matrix (time x dyad)
#' 
#' @examples
#' data(edgelistU)
#' out <- prepER(edgelist = edgelistU, directed = FALSE, type = FALSE, 
#'     riskset = NULL, actors = NULL)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors[,1]
#' stat <- triadU(ac, el, rs, unique_sp = FALSE, standardize = FALSE)
#'
#' @export
#'
triadU <- function(actors, edgelist, riskset, unique_sp, standardize) {
    .Call('_remstats_triadU', PACKAGE = 'remstats', actors, edgelist, riskset, unique_sp, standardize)
}

#' pshift
#'
#' A function to compute Gibson's (2003) dyadic participation shifts. 
#'
#' @param edgelist 3-column edgelist (time, sender, receiver)
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param type (1 = AB-BA, 2 = AB-BY, 3 = AB-XA, 4 = AB-XB, 5 = AB-XY, 
#' 6 = AB-AY)
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistD)
#' out <- prepER(edgelistD)
#' ABBA <- pshift(edgelist = out$edgelist, riskset = out$riskest, type = 1)
#'
#' @export
#'
pshift <- function(edgelist, riskset, type) {
    .Call('_remstats_pshift', PACKAGE = 'remstats', edgelist, riskset, type)
}

#' inertiaMW
#'
#' A function to compute the inertia effect.
#'
#' @param full_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_length numeric value.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2).
#' @param full_weights vector (length full_edgelist). 
#' @param standardize logical. 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' windows <- data.frame(start = seq(0, 900, 75), end = seq(100, 1000, 75))
#' data(edgelistU)
#' window_edgelist <- edgelistU[edgelistU$time > windows$start[2] & 
#'     edgelistU$time <= windows$end[2],]
#' out <- prepER(edgelist = edgelistU, directed = FALSE)
#' full_el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' out <- prepER(window_edgelist, directed = FALSE, actors = ac[,2])
#' window_el <- out$edgelist
#' stat <- inertiaMW(full_edgelist = full_el, window_edgelist = window_el, 
#'     window_length = 100, riskset = rs, 
#'     full_weights = rep(1, nrow(full_el)), standardize = FALSE)
#'
#' @export
#'
inertiaMW <- function(full_edgelist, window_edgelist, window_length, riskset, full_weights, standardize) {
    .Call('_remstats_inertiaMW', PACKAGE = 'remstats', full_edgelist, window_edgelist, window_length, riskset, full_weights, standardize)
}

#' triadUMW
#'
#' A function to compute the (unique) shared partners effect for undirected 
#' relational events when fitting a moving window REM.
#'
#' @param actors vector with numeric actor IDs (correspond to edgelist,
#' riskset)
#' @param full_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_edgelist 3-column edgelist (time, sender, receiver)
#' @param window_length numeric value.
#' @param riskset 2-column riskset (sender/actor 1, receiver/actor 2)
#' @param unique_sp logical value
#' @param standardize logical value
#'
#' @return matrix (time x dyad)
#' 
#' @examples
#' data(edgelistU)
#' windows <- data.frame(start = seq(0, 900, 75), end = seq(100, 1000, 75))
#' window_edgelist <- edgelistU[edgelistU$time > windows$start[2] & 
#'     edgelistU$time <= windows$end[2],]
#' out <- prepER(edgelist = edgelistU, directed = FALSE)
#' full_el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' out <- prepER(window_edgelist, directed = FALSE, actors = ac[,2])
#' window_el <- out$edgelist
#' stat <- triadUMW(actors = ac[,1], full_edgelist = full_el, 
#'     window_edgelist = window_el, window_length = 100, riskset = rs, 
#'     unique_sp = FALSE, standardize = FALSE)
#'
#' @export
#'
triadUMW <- function(actors, full_edgelist, window_edgelist, window_length, riskset, unique_sp, standardize) {
    .Call('_remstats_triadUMW', PACKAGE = 'remstats', actors, full_edgelist, window_edgelist, window_length, riskset, unique_sp, standardize)
}

#' typestat
#'
#' A function to compute a type effect/type dummy. 
#' @param edgelist 4-column edgelist (time, sender, receiver, type)
#' @param riskset 3-column riskset (sender/actor 1, receiver/actor 2, type)
#' @param type numeric value
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistDT)
#' out <- prepER(edgelist = edgelistDT, type = TRUE)
#' edgelist <- out$edgelist
#' riskset <- out$riskset
#' types <- unique(edgelist[,4])
#' stat <- typestat(edgelist, riskset, types[1])
#'
#' @export
#'
typestat <- function(edgelist, riskset, type) {
    .Call('_remstats_typestat', PACKAGE = 'remstats', edgelist, riskset, type)
}

#' inertia_type
#'
#' A function to compute the inertia_type effect.
#' 
#' @param edgelist 4-column edgelist (time, sender, receiver, type)
#' @param riskset 3-column riskset (sender/actor 1, receiver/actor 2, type)
#' @param weights vector (length edgelist) 
#' @param standardize logical 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' data(edgelistDT)
#' out <- prepER(edgelist = edgelistDT, type = TRUE)
#' edgelist <- out$edgelist
#' riskset <- out$riskset
#' equal_weights <- rep(1, nrow(edgelist))
#' stat <- inertia_type(edgelist, riskset, equal_weights, standardize = FALSE)
#'
#' @export
#'
inertia_type <- function(edgelist, riskset, weights, standardize) {
    .Call('_remstats_inertia_type', PACKAGE = 'remstats', edgelist, riskset, weights, standardize)
}

#' inertia_typeMW
#'
#' A function to compute the inertia_type effect for a moving window REM.
#'
#' @param full_edgelist 4-column edgelist (time, sender, receiver, type).
#' @param window_edgelist 4-column edgelist (time, sender, receiver, type).
#' @param window_length numeric value.
#' @param riskset 3-column riskset (sender/actor 1, receiver/actor 2, type).
#' @param full_weights vector (length full_edgelist). 
#' @param standardize logical. 
#'
#' @return matrix (time x dyad)
#'
#' @examples
#' windows <- data.frame(start = seq(0, 900, 75), end = seq(100, 1000, 75))
#' data(edgelistUT)
#' window_edgelist <- edgelistUT[edgelistUT$time > windows$start[2] & 
#'     edgelistUT$time <= windows$end[2],]
#' out <- prepER(edgelist = edgelistUT, directed = FALSE, type = TRUE)
#' full_el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' out <- prepER(window_edgelist, directed = FALSE, type = TRUE, 
#'    actors = ac[,2])
#' window_el <- out$edgelist
#' equal_weights <- rep(1, nrow(full_el))
#' stat <- inertia_typeMW(full_edgelist = full_el, window_edgelist = 
#'     window_el, window_length = 100, riskset = rs, 
#'     full_weights = equal_weights, standardize = FALSE)
#'
#' @export
#'
inertia_typeMW <- function(full_edgelist, window_edgelist, window_length, riskset, full_weights, standardize) {
    .Call('_remstats_inertia_typeMW', PACKAGE = 'remstats', full_edgelist, window_edgelist, window_length, riskset, full_weights, standardize)
}

#' triadU_type
#'
#' A function to compute the (unique) shared partners effect for undirected 
#' relational events with types. 
#'
#' @param actors vector with numeric actor IDs (correspond to edgelist,
#' riskset)
#' @param edgelist 4-column edgelist (time, sender, receiver, type)
#' @param riskset 3-column riskset (sender/actor 1, receiver/actor 2, type)
#' @param unique_sp logical value
#' @param standardize logical value
#'
#' @return matrix (time x dyad)
#' 
#' @examples
#' data(edgelistUT)
#' out <- prepER(edgelist = edgelistUT, directed = FALSE, type = TRUE)
#' el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors[,1]
#' stat <- triadU_type(ac, el, rs, unique_sp = FALSE, standardize = FALSE)
#'
#' @export
#'
triadU_type <- function(actors, edgelist, riskset, unique_sp, standardize) {
    .Call('_remstats_triadU_type', PACKAGE = 'remstats', actors, edgelist, riskset, unique_sp, standardize)
}

#' triadU_typeMW
#'
#' A function to compute the (unique) shared partners effect for undirected 
#' relational events with types for a moving window REM. 
#'
#' @param actors vector with numeric actor IDs (correspond to edgelist,
#' riskset)
#' @param full_edgelist 4-column edgelist (time, sender, receiver, type)
#' @param window_edgelist 4-column edgelist (time, sender, receiver, type)
#' @param window_length numeric value.
#' @param riskset 3-column riskset (sender/actor 1, receiver/actor 2, type)
#' @param unique_sp logical value
#' @param standardize logical value
#'
#' @return matrix (time x dyad)
#' 
#' @examples
#' data(edgelistUT)
#' windows <- data.frame(start = seq(0, 900, 75), end = seq(100, 1000, 75))
#' window_edgelist <- edgelistUT[edgelistUT$time > windows$start[2] & 
#'     edgelistUT$time <= windows$end[2],]
#' out <- prepER(edgelist = edgelistUT, directed = FALSE, type = TRUE)
#' full_el <- out$edgelist
#' rs <- out$riskset
#' ac <- out$actors
#' out <- prepER(window_edgelist, directed = FALSE, type = TRUE, 
#'     actors = ac[,2])
#' window_el <- out$edgelist
#' stat <- triadU_typeMW(ac[,1], full_edgelist = full_el, 
#'     window_edgelist = window_el, window_length = 100, riskset = rs, 
#'     unique_sp = FALSE, standardize = FALSE)
#'
#' @export
#'
triadU_typeMW <- function(actors, full_edgelist, window_edgelist, window_length, riskset, unique_sp, standardize) {
    .Call('_remstats_triadU_typeMW', PACKAGE = 'remstats', actors, full_edgelist, window_edgelist, window_length, riskset, unique_sp, standardize)
}

recency <- function(edgelist, actors, type) {
    .Call('_remstats_recency', PACKAGE = 'remstats', edgelist, actors, type)
}

